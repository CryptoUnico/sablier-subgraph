import { Cancellation, Stream, Withdrawal } from "../types/schema";
import {
  CreateStream as CreateStreamEvent,
  CreateCompoundingStream as CreateCompoundingStreamEvent,
  WithdrawFromStream as WithdrawFromStreamEvent,
  CancelStream as CancelStreamEvent,
  PayInterest as PayInterestEvent,
} from "../types/Sablier/Sablier";
import { addToken } from "./tokens";
import { addStreamTransaction } from "./transactions";

export function handleCreateStream(event: CreateStreamEvent): void {
  // Create the stream entity.
  let streamId = event.params.streamId.toString();
  let stream = new Stream(streamId);
  stream.deposit = event.params.deposit;
  stream.ratePerSecond = event.params.deposit.div(event.params.stopTime.minus(event.params.startTime));
  stream.recipient = event.params.recipient;
  stream.sender = event.params.sender;
  stream.startTime = event.params.startTime;
  stream.stopTime = event.params.stopTime;
  stream.timestamp = event.block.timestamp;
  stream.token = event.params.tokenAddress.toHex();
  stream.save();

  // Create adjacent but important entities.
  addStreamTransaction("CreateStream", event, streamId);
  addToken(event.params.tokenAddress.toHex());
}

export function handleCreateCompoundingStream(event: CreateCompoundingStreamEvent): void {
  let streamId = event.params.streamId.toString();
  let stream = Stream.load(streamId);
  if (stream == null) {
    return;
  }

  stream.exchangeRateInitial = event.params.exchangeRate;
  stream.senderSharePercentage = event.params.senderSharePercentage;
  stream.recipientSharePercentage = event.params.recipientSharePercentage;
  stream.save();

  addStreamTransaction("CreateCompoundingStream", event, streamId);
}

export function handleWithdrawFromStream(event: WithdrawFromStreamEvent): void {
  let streamId = event.params.streamId.toString();
  let stream = Stream.load(streamId);
  if (stream == null) {
    return;
  }

  let withdrawal = new Withdrawal(event.transaction.hash.toHex() + "-" + event.logIndex.toString());
  withdrawal.amount = event.params.amount;
  withdrawal.stream = streamId;
  withdrawal.timestamp = event.block.timestamp;
  withdrawal.token = stream.token;
  withdrawal.save();

  addStreamTransaction("WithdrawFromStream", event, streamId);
}

export function handleCancelStream(event: CancelStreamEvent): void {
  let streamId = event.params.streamId.toString();
  let stream = Stream.load(streamId);
  if (stream == null) {
    return;
  }

  let cancellation = new Cancellation(streamId);
  cancellation.recipientBalance = event.params.recipientBalance;
  cancellation.senderBalance = event.params.senderBalance;
  cancellation.timestamp = event.block.timestamp;
  cancellation.token = stream.token;
  cancellation.txhash = event.transaction.hash.toHex();
  cancellation.save();

  stream.cancellation = streamId;
  stream.save();

  addStreamTransaction("CancelStream", event, streamId);
}

export function handlePayInterest(event: PayInterestEvent): void {
  // This event could be generated by either a `withdrawFromStream` or `cancelStream` tx.
  // We have to check for both - we can't know beforehand.
  let streamId = event.params.streamId.toString();
  let stream = Stream.load(streamId);
  let cancellation = Cancellation.load(streamId);

  if (cancellation != null) {
    cancellation.recipientInterest = event.params.recipientInterest;
    cancellation.sablierInterest = event.params.sablierInterest;
    cancellation.senderInterest = event.params.senderInterest;
  } else if (stream.withdrawals) {
    // Without first storing the array in this variable, the compiler throws an error:
    // AS100: Operation not supported
    let withdrawals: string[] = stream.withdrawals as string[];
    let withdrawalIndex = withdrawals.length;
    let withdrawalId = withdrawals[withdrawalIndex];
    let withdrawal = Withdrawal.load(withdrawalId.toString());
    withdrawal.recipientInterest = event.params.recipientInterest;
    withdrawal.sablierInterest = event.params.sablierInterest;
    withdrawal.senderInterest = event.params.senderInterest;
  }
}
